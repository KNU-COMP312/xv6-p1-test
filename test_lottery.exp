#!/usr/bin/expect -f
# Env overrides (optional):
#   CPUS=1 SCHED=lottery TOL=0.35 ./tests/test_lottery.exp

# Kill any running QEMU processes (ignore errors)
catch { exec pkill -f qemu-system-riscv64 } result

set timeout 120
set cpus  [expr {[info exists env(CPUS)]  ? $env(CPUS)  : 1}]
set sched [expr {[info exists env(SCHED)] ? $env(SCHED) : "lottery"}]
set tol   [expr {[info exists env(TOL)]   ? double($env(TOL)) : 0.20}]

puts "INFO: starting xv6 (CPUS=$cpus, SCHED=$sched)"
spawn make clean
spawn make qemu CPUS=$cpus SCHED=$sched

expect {
  -re {xv6 kernel is booting} { }
  timeout { puts "ERROR: boot timeout (no 'xv6 kernel is booting')"; exit 124 }
}

expect {
  -re {init: starting sh} { }
  timeout { puts "ERROR: boot timeout (no 'init: starting sh')"; exit 124 }
}

expect -re {\$ $}
send -- "lotterytest\r"

# collect results. format: `T=10 loops=1234`
set reports {}
set need 3

proc quit_qemu {} {
  # Ctrl-a x
  send -- "\001x"
  expect eof
}

while {$need > 0} {
  expect {
    -re {T=(\d+)\s+loops=(\d+)\r\n} {
      set t $expect_out(1,string)
      set l $expect_out(2,string)
      lappend reports [list $t $l]
      incr need -1
    }

    -re {lotterytest: unknown sys call [0-9]+\r\n} {
      puts "ERROR: unknown syscall"
      quit_qemu
      exit 3
    }
    -re {settickets failed\r\n} {
      puts "ERROR: settickets failed"
      quit_qemu
      exit 4
    }
    -re {ready read failed\r\n} {
      puts "ERROR: parent failed to read 'ready' (child crashed or pipe issue)"
      quit_qemu
      exit 5
    }
    -re {exec .* failed\r\n} {
      puts "ERROR: exec failed (lotterytest not in UPROGS or fs.img missing the binary)"
      quit_qemu
      exit 7
    }
    -re {panic: .*\r\n} {
      puts "ERROR: kernel panic"
      quit_qemu
      exit 6
    }

    timeout {
      puts "ERROR: did not see all reports in time (got [llength $reports])"
      quit_qemu
      exit 2
    }

    eof {
      puts "ERROR: QEMU exited early (got [llength $reports] reports)"
      exit 2
    }
  }
}

proc compare {a b} {
  set ta [lindex $a 0]
  set tb [lindex $b 0]
  if {$ta < $tb} {return -1}
  if {$ta > $tb} {return 1}
  return 0
}
set reports [lsort -command compare $reports]

set ratios {}
foreach rep $reports {
  set t [lindex $rep 0]
  set l [lindex $rep 1]
  lappend ratios [expr {double($l) / double($t)}]
}

set sum 0.0
foreach r $ratios { set sum [expr {$sum + $r}] }
set mean [expr {$sum / [llength $ratios]}]

set maxdev 0.0
foreach r $ratios {
  set dev [expr {abs($r - $mean) / $mean}]
  if {$dev > $maxdev} { set maxdev $dev }
}

send -- "\001x"
expect eof

puts "RESULT: reports=$reports"
puts [format "RESULT: mean_loops_per_ticket=%.3f  max_rel_dev=%.3f  tol=%.3f" $mean $maxdev $tol]

if {$maxdev <= $tol} {
  puts "PASS: proportional within tolerance"
  puts "SUCCESS: All tests passed!"
  set code 0
} else {
  puts "FAIL: not proportional"
  set code 1
}

exit $code
